Комаров Максим 
Метелев Никита

DS1. Даны два бинарных дерева поиска. Известно, все элементы одного дерева больше или равны элементов другого. Предложите алгоритм объединения двух деревьев в одно за O(log(N1 +N2))


Так как все элементы одного дерева, больше или равны элементов второго дерева, то, чтобы объединить их достаточно, присоединить меньшее второе дерево, к первому, как его поддерево, с корнем из самого меньшего элемента первого дерева, который больше или равен корню второго дерева.

DS3. Дано K упорядоченных списков чисел. Нужно вернуть первые N элементов из их объединения. Предложите алгоритм эффективнее тривиального, то есть быстрее, чем за O(NK)

Создаём бинарное дерево поиска.
Добавляем элементы из K списков, начиная с концов этих списков, в это дерево.
Самый левый элемент в дереве всегда будет самым меньшим, т.к. бинарное дерево обладает свойством самоупорядовачивания. 
Поэтому изымая N элементов по порядку начиная с самого нижнего левого, мы получим первые N элементов из объединения этих списков

DS4. Спроектировать класс, для представления детерминированного конечного автомата (ДКА).
что-то такое:

    public static class StateMachine
    {
        public static char[] enterString;//строка на вход
        public static State currentState;//текущее состояние
        public static State nextState;//будущее состояние
        public static int pointer;//указатель, на каком символе строки мы находимся

        public static void ChangeState(State state)
        {
            nextState = state;
        }

        public static void Check()
        {
            //здесь проходимся по строке переходя, когда нужно из currentState в nextState,
        }

    }

    public class State
    {
        public char goNext;
        public char revert;

        public State(char goNext, char revert)
        {
            //инициализируем
        }
            

        public void Transition()
        {
            //здесь если поинтер указывает на символ, из-за которого мы переходим в новое состояние, мы изменяем nextTste и переводим поинтер вперёд,
            //если поинтер указывает на символ, из-за которого мы остаёмся в том же состоянии, то просто переводим поинтер вперёд
            //иначе ошибка
        }
    }

DS2. Пересечение отрезков. Дано N отрезков, каждый из которых параллелен либо оси X, либо оси Y. Необходимо найти любые два пересекающихся отрезка, либо сказать, что таких нет. Сложность — быстрее, чем за O(N^2)

Сортируем начальные точки отрезков по координате X.
Далее проходимся по точкам
Кладём первую начальную точку в стэк, если следующая точка - конец этого отрезка, убираем точку из стэка
Иначе добавляем начальную точку следующего отрезка, и так как первый отрезок ещё не закончился, то эти отрезки могут пересечься, сохраняем эту информацию(отрезки, которые могут пересекаться)
Когда отрезок кончился, убираем его из стэка и продолжаем процедуру.

В итоге, пройдясь по всем точка 1 раз, у нас будут списки отрезков, которые могут пересекаться.
Проверяем действительно ли отрезки, которые мы подозреваем на возможность пересечься, пересекаются.
И находим пересекающиеся между собой отрезки быстрее, чем за O(N^2)
